=The Typeclassopedia

by Brent Yorgey <byorgey@cis.upenn.edu>

標準Haskellライブラリには、代数や圏論に裏打ちされた数多くの型クラスが用意されています。流暢なHaskellハッカーになるためには、これら全てに根本的に慣れ親しんでいる必要がありますが、慣れ親しむためには、しばしば山ほどのチュートリアルやブログの記事、メーリングリストのアーカイブ、IRCのログをくまなくチェックする必要があります。

この記事に目的は、標準の型クラスについてしっかり理解したいと望んでいるHaskell学習者のはじめの一歩となることです。それぞれの型クラスの基本的なことを、例や注釈と更なる読み物への参照とともに紹介します。


==序論
いままでこんなことを考えたことがありませんか?

*いったいモノイドとは何で、モナドとは何が違うのか?

*ようやくParsecをdo記法と共に使うやり方がわかったのに、代わりにApplicativeを使うべきだと言われた。それは何?

*#haskell IRCチャンネルで、誰かが(***)を使っていたので、lambdabotにその型を尋ねたら、回りくどくてわかりにくい一行に収まらないような型が表示された。さらには、誰かがfmap fmap fmapを使ったので、訳が分からなくなった。

*すごく複雑なことのやり方を尋ねたら、みんながzip.ap fmap.(id &&& wtf)みたいなのideomaticをタイプし始め、びっくりすることにそれらはちゃんと動いた! それはともかく、そんなものを2秒で思いつく方法なんてあるわけがないから、彼らはロボットに違いないと思う。

そんなことを考えたことがあれば、これ以上探す必要はありません。あなたも彼らと同じように簡潔でエレガントで慣用的なHaskellのコードを書いたり理解したりすることができます。

エキスパートなHaskellハッカーになるための二つの鍵があります。一つ目は型を理解すること。二つ目は、それぞれの型クラス、そしてそれらと他の型クラスとの関係について、たくさんの例に馴染みながら深い洞察を得ることです。

一つ目の鍵は特に重要です。型シグニチャを我慢強く学習すれば、深い秘密を暴くことができます。逆に、コードの中で型について意識しない人は、永遠に確信が持てない運命なのです。「ああ、これはコンパイルできない…たぶん、このfmapが良くないんだろう。いや、ちょっと待て…おそらくどこかに(.)がもう一つ必要なんじゃないか?」

二つ目の鍵、つまり例に基づいて深い洞察を得ること、もまた重要ですが、さらに達成するのは難しいことです。この記事の主要なゴールは、あなたをそのような洞察を得る軌道に乗せることです。しかし、

Haskellに王道なし ---Euclid

この記事ははじめの一歩に過ぎません。なぜならば、良い洞察は猛勉強からしか得られず、良いメタファー[1]を学ぶことからは得られないからです。この記事の全てを読んで理解したとしても、まだ険しい旅が待っています。しかし、良いはじめの一歩は、時に大きな違いを生み出します。

この記事がHaskellのチュートリアルではないことは明記しておいた方が良いでしょう。読者は、標準Preludeや型システム、データ型、型クラスなどのHaskellの基礎について馴染みがあると仮定しています。

図1はこれから私たちが議論する型クラスと、それらの間の関係を表しています。実線の矢印は、一般的なものから具体的なものに引かれています。つまり、もしFooからBarへの矢印があれば、それは全てのBarはFooである（もしくは、Fooであるべきであるか、Fooにすることができる）という意味です。破線の矢印はその他の何らかの関係を表しています。二重の実線の矢印は、MonadとArrowApplyが同等のものであることを表しています。PointedとComonadは、標準Haskellライブラリに（まだ）入っていないので、灰色になっています（それらは、category-extraライブラリ[2]にあります）。

始める前にもう一つの注意があります。"type class"が"typeclass"と一つの単語として書かれているのを見たことがありますが、ここではっきりさせておきましょう。正しい綴りは二つの単語を使います（この記事のタイトルにも関わらず）。このことは、例えばHaskell 98 Revised Report[3]や、型クラスに関する初期の論文[4,5]、そしてHudak達のHaskellの歴史[6]を見れば明らかです。

それではもっとも単純な型クラスであるFunctorから始めましょう。


==Functor
Functorクラスは、Haskellのライブラリの中で、もっとも基本的でどこにでもある型クラスです。Functorは、コンテナ内の各要素に対して関数を適用することができるような何らかの「コンテナ」である、というのが単純な洞察です。例えば、リストは要素のコンテナで、mapを使って各要素に関数を適用することができます。二分木も要素のコンテナで、木の中の各要素に関数を再帰的に適用する方法は簡単に思いつきます。

別の洞察では、Functorは何らかの「計算の文脈」を表します。この洞察は一般的にはもっと有用ですが、あまりにも一般的すぎて説明するのがもっと難しいものです。後で示すいくつかの例が、文脈としてのFunctorという見方を明確にするのを助けてくれるはずです。

最後になりますが、とはいっても、Functorは単にそのように定義されたものに過ぎません。おそらく上の二つの洞察にぴったりそぐわないFunctorのインスタンスの例はたくさんあります。賢い生徒は定義と例に注目し、特定のメタファーから学びすぎないようにするでしょう。洞察はいつかそれそのものとして得ることができます。


===定義
リスト5は、Functorの型クラスの定義を示しています。FunctorはPreludeから公開されているので、使うために特別なインポートは必要ありません。

 class Functor f where
   fmap :: (a -> b) -> f a -> f b
 
 リスト5: Functor型クラス

まず、fmapの型シグニチャのf aとf bを見れば、fが単なる型ではないことがわかります。これは他の型を引数に取る型構築子なのです（もっと正確な言い方をするならば、fの種は* -> *でなくてはなりません）。例えば、Maybeはそのような型構築子です。Maybeはそれ自体は型ではなく、Maybe Integerのように、他の型が引数として必要です。ですから、instance Functor Integerということはできませんが、instance Functor Maybeということはできます。

さて、fmapの型を見てみましょう。fmapは、aからbへの任意の関数とf a型の値を取り、f b型の値を出力します。コンテナという見方からすると、fmapは、コンテナの構造を変えることなく、コンテナの各要素に対して関数を適用すると言うことができます。文脈という見方からすると、fmapは文脈を変えることなく値に関数を適用すると言えます。いくつかの具体的な例を見てみましょう。


===インスタンス
先に述べたように、リストの構築子である[]はファンクタです。標準のリスト関数であるmapを使って、リストの各要素に関数を適用することができます。Maybe型構築子も同様にファンクタで、ひとつの要素を保持しているかも知れないコンテナをあらわします。fmap g関数はNothingに対しては何もせず（gが適用され得る要素がありません）、単にJustのひとつの要素に対してgを適用します。あるいは、文脈という解釈では、リストのファンクタは非決定的な選択の文脈を表します。つまり、リストは、いくつかの可能性（リストの要素）から非決定的に選ばれるひとつの値を表している、と考えられます。同様にMaybeのファンクタは失敗が起こりうる文脈を表現します。これらのインスタンスは、リスト6に示されています。

 instance Functor [] where
   fmap _ []     = []
   fmap g (x:xs) = g x : fmap g xs
   -- もしくは単にfmap = mapとも言えます
 
 instance Functor Maybe where
   fmap _ Nothing  = Nothing
   fmap g (Just a) = Just (g a)
 
 リスト6: 二つの単純なFunctorインスタンス

余談としてですが、よく見るであろう慣用的なHaskellのコードでは、fは任意のFunctorと任意の関数の両方をあらわすのに使われます。このチュートリアルでは、fはFunctorをあらわすのに使い、関数はgやhであらわしますが、混乱しないように気をつけてください。実際には、fが何を表すかは、型の一部として現れたか、コードの一部として現れたかという文脈から常に明らかです。

Haskellの標準ライブラリには他にもFunctorのインスタンスがあります。いくつかを取り上げます。

*Either eはFunctorのインスタンスです。Either e aはa型の値かe型の値のどちらかを含むコンテナを表します（しばしば何らかのエラーを表します）。起こりうる失敗を表すという点でMaybeと似ていますが、失敗に関する追加の情報を持つことができます。

*((,) e)はe型の「注釈」を実際の値と共に保持するコンテナを現します。

*((->) e)、つまりe型の値を引数に取る関数はFunctorです。(1+)のような演算子セクションと同様に(e ->)のように書けるともっと明確なのですが、このような書き方は許されていません。しかし、(e ->)だと考えてもらってかまいません。コンテナとしては、(e -> a)は、e型の値で指定される、（無限に存在するかもしれない）a型の値の集合を表します。あるいは、もっと役に立つ方法として、(e ->)は型eの値が読み込み専用として参照できる文脈だと考えることができます。このことは、((->) e)が時々リーダーモナドと言われる訳でもあります。詳細は後ほど。

*IOはFunctorです。IO a型の値は、型aの値を生成する、I/Oを伴うかも知れない計算を表します。もし、mが何らかのI/Oを伴って値xを計算するのならば、fmap g mは同じI/Oを伴い値g xを計算します。

containersライブラリ[8]にある（Tree, Map, Sequence, Streamのような）沢山の標準の型はFunctorのインスタンスです。注意すべき例外はSetで、（数学的には確かにファンクタなのですが）HaskellではFunctorにすることができません。これは、Setが要素に対してOrd制約を必要とするからです。fmapはあらゆる型aとbに対して適用できなくてはなりません。

Either e、((,) e)、((->) e)のFunctorのインスタンスを実装してみるのは良い練習になります。


===法則
Haskell言語が関知する限りにおいては、Functorに対する要件は正しい型でfmapを実装することだけです。しかし、理にかなったFunctorのインスタンスは全て同様にファンクタ法則を満たします。この法則は、数学におけるファンクタの定義の一部です。リスト7に示される二つの法則を合わせると、fmap gがコンテナの構造を変えず、要素だけを変更することが保証されます。同等に、そしてもっと単純に、これらの法則はfmap gが文脈を変えずに値を変えることを保証します。

 fmap id = id
 fmap (g . h) = fmap g . fmap h
 
 リスト7: Functor法則

最初の法則は、コンテナの各要素に恒等関数を適用しても変化が無いことを意味します。二つ目の法則は、二つの関数を合成した関数をコンテナの各要素に適用するのは、初めに一つ目の関数を適用し、次に二つ目の関数を適用するのと同じであることを意味します。

例として、リスト8に示したコードは、正当なFunctorのインスタンス（型チェックができる）ですが、ファンクタ法則を破っています。なぜだかわかりますか?

 instance Functor [] where
   fmap _ [] = []
   fmap g (x:xs) = g x : g x : fmap g xs
 
 リスト8: 法則に従わないFunctorインスタンス

有能なHaskellerは、リスト8のコードを、ぞっとする大嫌いなものとして排除するでしょう。


===洞察
fmapについて考える根本的な方法が二つあります。一つ目は既に触れた方法です。fmapは、関数とコンテナの二つの引数をとり、関数をコンテナの「内部」に適用にして新しいコンテナを生成します。あるいは、fmapを文脈内の値に（文脈を変更せずに）関数を適用することだと考えることもできます。

しかし、他の全ての「ひとつ以上の引数を取る」Haskellの関数と同様に、fmapは実際にはカリー化されています。つまり、実際には二つの引数を取るのではなく、ひとつの引数を取って関数を返します。強調するために、fmapの型を追加の括弧をつけて、fmap :: (a -> b) -> (f a -> f b)と書くことができます。このような形で書くと、fmapが「普通の」関数（g :: a -> b）を、コンテナ・文脈に対して作用する関数（fmap g :: f a -> f b）に変換していることが明らかになります。この変換はしばしば持ち上げと呼ばれます。つまり、fmapは関数を「普通の世界」から「fの世界」に持ち上げるわけです。


===更なる読み物
ファンクタの概念の背後にある圏論について読むのに、圏論についてのHaskell wikibookのすばらしいページ[9]が良い取っ掛かりとなるでしょう。



==Pointed
Pointed型クラスは、基点付きファンクタを表します。この型クラスは、実際には標準ライブラリには含まれません。しかし、標準ライブラリに含まれうるものですし、この型クラスはApplicativeやMonadのような他の型クラスを理解する助けとなるので、しばらく標準に含まれているとしましょう。

Functorがあるとして、Pointedクラスは値を「デフォルトの文脈」に入れる追加の機能を表します。しばしば、このことはただひとつの要素だけをもったコンテナを作成することに対応しますが、実際にはもっと一般的なものです。リスト9にこの型クラスの宣言を示します。

 class Functor f => Pointed f where
   pure :: a -> f a     -- またの名を、signleton, return, unit, point
 
 リスト9: Pointed型クラス

ほとんどの標準のFunctorインスタンスは、Pointedのインスタンスでもあります。たとえば、MaybeのPointedインスタンスでは、pure = Justになります。リストの実装は沢山ありえますが、もっとも自然なものは、pure x = [x]です。((-> e)に対しては、考えてみてください（単に型に従いましょう）。

PointedでないFunctorの例としては、((,) e)があります。もし、pure :: a -> (e, a)を実装しようとすれば、それがなぜだかわかるはずです。型eは完全に任意なので、何も無いところから型eの値を作り出すことはできないからです。しかし、後で見るように、((,) e)は、eに、型eのデフォルトの値を生成することができるような追加の制約を課すならばPointedにすることができます（最も一般的な解決方法は、eをMonoidのインスタンスにすることです）。

Pointedクラスは、リスト10で示されるようなただひとつの法則を持ちます。

 fmap g . pure = pure . g
 
 リスト10: Pointed法則

しかし、この法則について心配する必要はありません。この法則はパラメトリシティ[11]によって保証される、いわゆる「ただで手に入る定理」です。この法則に従わないPointedのインスタンスを書くことは不可能です。



==Applicative
やや新しく標準Haskell型クラスの伝道に追加された、アプリカティブファンクタは、ちょうどFunctorとMonadの間に位置する抽象化を表し、McBrideとPaterson[12]によって初めて述べられました。McBrideとPatersonの古典的論文のタイトルである、Applicative Programming with Effectsは、Applicative型クラスの裏にある洞察に関するヒントを与えてくれます。この型クラスは、関数的に純粋な方法で行われるある種の「副作用のある」な計算をカプセル化し、「アプリカティブ」なプログラミングスタイルを推し進めます。正確にどんなことを意味するのかは、この後で明らかにされます。


===定義
Applicativeクラスは、ひとつの昨日をPointedファンクタに追加します。Functorクラスが「通常の」関数を計算の文脈の関数に持ち上げることができることを思い出してください。しかし、fmapはそれ自体が文脈の中にある関数を、他の文脈にある値に適用することはできません。Applicativeはまさにそのためのツールを与えてくれます。リスト10は、Control.Applicativeで定義されている、Applicative型クラスの宣言を示しています。全てのApplicativeは同時にFunctorでなくてはならないことに注意してください。実は、後で見るように、fmapはApplicativeのメソッドを使って実装することができまので、好む好まざるにかかわらず、すべてのApplicativeはファンクタになります。Functor制約は、我々を正直にさせるのです。

 class Functor f => Applicative f where
   pure :: a -> a
   (<*>) :: f (a -> b) -> f a -> f b
 
 リスト11: Applicative型クラス

いつものように、(<*>)の型シグニチャを理解するのは必須です。(<*>)を考えるにあたってもっとも良い方法は、(<*>)の型が($)の型に似ているけれど全てがfの中に閉じ込められていることに注目することです。別の言い方をすると、(<*>)は、単に計算の文脈における関数適用に過ぎないのです。(<*>)の型はまたfmapの型にとてもよく似ています。たった一つの違いは、最初の引数が(a -> b)という「普通の」関数ではなくて、f (a -> b)という文脈の中の関数であることです。

もちろん、pureはさらに見慣れたものです。もし既にPointed型クラスがあれば、Applicativeはリスト12に示されたように定義されるでしょう。

 class Pointed f => Applicative' f where
   (<*>) :: f (a -> b) -> f a -> f b
 
 リスト12: Pointedを使ったApplicativeの別の定義


===法則
Applicativeのインスタンスが満たすべき法則[11,12]はいくつかありますが、洞察を養うにはそのうちのひとつが重要です。なぜなら、その法則がApplicativeがFunctorとどのように関連するかを明確にするからです（他の4つは、主にpureがその名前の通りに振舞うことの正確な意義を明確にします）。リスト13にこの法則を示します。

 fmap g x = pure g <*> x
 
 リスト13: ApplicativeのFunctorに対する関係に関する法則

この法則は、純粋な関数gを文脈xに対してマップするのは、初めにpureを使用してgを文脈に注入してからそれを(<*>)を使ってxに適用するのと同じである、ということです。別の言い方をすると、fmapは二つのもっと原始的な操作、つまり文脈への注入と、文脈内での適用、に分解することができます。Control.Applicativeモジュールは、同様に(<$>)をfmapの別名として定義しているので、上記の法則は、g <$> x = pure g <*> xと表現することもできます。


===インスタンス
Functorのインスタンスである標準型のほとんどはApplicativeのインスタンスです。

Maybeは簡単にApplicativeのインスタンスにすることができます。そのようなインスタンスを書くことは読者の練習として残しておきます。

リストの型構築子である[]は実際のところ二種類の方法でApplicativeのインスタンスにすることができます。それは、リストを順序付けられた要素のコレクションとして扱いたいか、非決定的計算の複数の結果を表す文脈として扱いたいかに依ります。

最初にコレクションの見方から考えてみましょう。特定の型の型クラスのインスタンスはひとつしか存在し得ないので、ひとつ、または両方のリストのApplicativeのインスタンスはnewtypeのラッパーに対して定義する必要があります。偶然にも、非決定性計算のインスタンスがデフォルトで、コレクションのインスタンスは、ZipListという名前のnewtypeに関して定義されています。リスト14にこのインスタンスを示します。

 newtype ZipList a = ZipList { getZipList :: [a] }
 
 instance Applicative ZipList where
   pure = undefined   -- 練習
   (ZipList gs) <*> (ZipList xs) = ZipList (zipWith ($) gs xs)
 
 リスト14: ZipListのApplicativeインスタンス

(<*>)を使って関数のリストを入力のリストに適用にするには、要素ごとに関数と入力を対応させ、結果の出力のリストを生成します。言い換えると、二つのリストを関数適用である($)で「zip」します。そういうわけで、ZipListという名前なのです。練習として、pureを正しく定義してみてください。リスト13に示される法則を満たす実装はひとつしかありません。

リスト15に、非決定性計算の視点から見た、リストに対するもうひとつのApplicativeのインスタンスを示します。入力のペアに対して関数を適用する代わりに、それぞれの関数を全ての入力に対して順番に適用し、全ての結果をリストに集めます。

 instance Applicative [] where
   pure x = [x]
   gs <*> xs = [ g x | g <- gs, x <- xs ]
 
 リスト15: []のApplicativeインスタンス

これで、非決定性計算を自然なスタイルで書くことができるようになりました。3と4を決定的に足すには、もちろん、(+) 3 4と書くことができます。しかし、3の代わりに2、3か4が結果となるような非決定性計算を考えるならば、以下のように書くことができます。

 pure (+) <*> [2,3,4] <*> pure 4

もしくは、もっと慣習的に、以下のように書きます。

 (+) <$> [2,3,4] <*> pure 4

他にもいくつかのApplicativeのインスタンスがあります。

*IOはApplicativeのインスタンスで、あなたが考えるであろうその通りに振舞います。g <$> m1 <*> m2 <*> m3が実行されると、miの副作用が左から右の順で発生します。

*((,) a)は、aがMonoidのインスタンスである限りApplicativeです。aの値は、計算と同時に累算されます。

*ApplicativeモジュールはConst型構築子を定義しています。Const a b型の値は単にaを保持します。この型は、任意のMonoid aに対してApplicativeのインスタンスになります。このインスタンスは、Foldableなどと組み合わせたときに特に便利です。

*WrappedMonadやWrappedArrow newtypeは、あらゆるMonadやArrowのインスタンスをApplicativeのインスタンスにします。これらの型クラスを学ぶときに見るように、これらの型クラスは厳密にApplicativeよりも表現力があり、その意味で、それらの型クラスのメソッドを使用してApplicativeのメソッドを実装することができます。


===洞察
McBrideとPatersonの論文は、計算文脈における関数適用を表すのに、[[g x1 x2 ... xn]]という記法を導入しました。各xiが何らかのアプリカティブファンクタであるfに対してf tiという型を持ち、gが、t1 -> t2 -> ... -> tn -> tという型を持つならば、[[ g x1 ... xn]]全体はf tという型になります。これは、複数の「副作用のある」引数への関数の適用と考えることができます。この意味で、二重鍵括弧記法は、文脈内でひとつの引数に対して関数を適用することができるfmapの一般化と言えます。

なぜ、このfmapの一般化を実装するのにApplicativeが必要なのでしょうか?fmapを使って、最初の引数x1にgを適用するとします。そうすると、f (t2 -> ... t)という型の何かを得ますが、ここで詰まってしまいます。この文脈内の関数をfmapを使って次の引数に適用することができません。しかし、これはまさに(<*>)ができることなのです。

このことから、理想的な[[g x1 x2 ... xn]]という記法をHaskellに適切に変換すると、

 g <$> x1 <*> x2 <*> ... <*> xn

となることがわかります。ここでは、Control.Applicativeがfmapの便利な中記法である(<$>)を定義していることを思い出してください。このことが、「アプリカティブスタイル」の意味するところなのです。つまり、副作用のある計算が、関数適用の形で表せるということです。唯一の違いは、関数適用するために、単に並べるだけではなく、特殊な演算子である(<*>)を使わなくてはいけないことだけです。


===更なる読み物
標準ライブラリには、他にもpureと(<*>)を使って実装した沢山の便利なコンビネータがあります。例えば、(*>)、(<*)、(<**>)、(<$)など[11]です。これらの二次的なコンビネータを賢く使うと、Applicativeを使ったコードはずっと読みやすくなります。

McBrideとPatersonのオリジナルの論文[12]は、情報と例、そしてApplicativeと圏論のつながりについての考察の宝庫です。初心者は読み通すのが難しいと思うかもしれませんが、非常に良く動機付けされていて、初心者であってもわかるところだけ読むだけで何かを得ることができるでしょう。

Conal Elliottは、Applicativeの最大の支持者の一人です。例えば、関数的イメージのためのPanライブラリ[14]や、関数的反応プログラミング(FRP)のreactiveライブラリ[15]は、Applicativeを重点的に使っています。彼のブログには実践的なApplicativeの例が沢山あります。McBrideとPatersonの研究を基にして、ElliottはTypeComposeライブラリ[17]も作成しました。このライブラリは、Applicativeな型は合成に関して閉じていて、だからApplicativeのインスタンスは複数の簡単な型に基づいた複雑な型に対して自動的に派生させられる、という（他の人たちの）見解を具体化します。

Parsec解析ライブラリ[18,19]は元々はモナドとして使うようにデザインされましたが、ほとんどの良くある場面で、Applicativeのインスタンスが大きな効果を発揮するために使えます。Bryan O'Sullivanのブログ記事[20]が良い取っ掛かりになります。もし、Monadによってもたらされる更なる力が必要ないのであれば、代わりにApplicativeを使うのは通常良い考えです。

他にもApplicativeの実践的な良い例は、ConfigFileやHSQLライブラリ[21]、formletsライブラリ[22]にも見られます。


==Monad
この記事を読んでいるということは、ApplicativeやArrow、Monoidについて聞いたことがなかったとしても、モナドについては間違いなく聞いたことがあるでしょう。なぜモナドはHaskellにおいてそれほど重要なのでしょうか?それにはいくつかの理由があります。

*実際、HaskellはモナドをI/Oを行うためのフレームワークとして使うことで、モナドに特別な注目を集めさせているからです。

*Haskellはまた、モナドのための特別なシンタックスシュガーであるdo記法を提供することで、モナドを有名にしているからです。

*Monadは、ApplicativeやArrowのようなほかの抽象モデルよりも長い間存在するからです。

*モナドに関するチュートリアルが沢山あればあるほど、人々はモナドが難しいに違いないと思い、モナドをついに理解したと思った人が更なる新しいモナドのチュートリアル[1]を書くからです。

これらが正しい理由かどうかはあなたが判断してください。

結局、あらゆる誇大広告にもかかわらず、Monadはまた別の単なる型クラスに過ぎません。では、定義を見てみましょう。


===定義
リスト16にMonadの型クラスの定義を示します。Monad型クラスはPreludeから、いくつかの標準的なインスタンスと共に公開されています。しかし、多くの便利な関数はControl.Monadにあり、（((->) e)のような）いくつかのインスタンスはControl.Monad.Instancesにあります。

 class Monad m where
   return :: a -> m a
   (>>=)  :: m a -> (a -> m b) -> m b
   (>>)   :: m a
   m >> n = m >>= \_ -> n
   
   fail   :: String -> m a
 
 リスト16: Monad型クラス

Monadクラスのメソッドを一つ一つ見ていきましょう。returnの型には馴染みがあるはずです。それは、pureと同じです。実際、returnはpureのことなのですが、不幸な名前を持っています（なぜ不幸かといえば、命令型プログラミングの世界からやってきた人は、実際には類似性はほとんど無いのに、returnは同じ名前のCやJavaのキーワードと同じようなものだと考えるからです）。数学的な見方をすると、あらゆるモナドは、基点付きファンクタ（実際にはアプリカティブファンクタ）ですが、歴史的な理由でMonadクラスの宣言は残念なことにこれらから派生していません。

(>>)はデフォルトの実装のある(>>=)の特別なバージョンだとわかります。(>>)が型クラスの宣言に含まれているのは、Monadの特定のインスタンスがより効率的な実装でデフォルトの実装を置き換えることができるようにするためです。さらに、_ >> n = nは型としては正しい(>>)の実装ですが、意図された意味論に対応していません。つまり、m >> nはmの結果を無視しますが、その副作用は無視しないことを意図しています。

fail関数はMonadクラスにいるべきではないひどいハックです。詳細は後ほど。

本当に興味深いただひとつのことは、Monadを真にPointedやApplicativeやより力強くしている(>>=)です。(>>=)はしばしば束縛と呼ばれます。リスト17にMonadの別の定義を示します。

 class Applicative m => Monad' m where
   (>>=) :: m a -> (a -> m b) -> m b
 
 リスト17: Monadの別の定義

(>>=)の裏にある洞察についてしばらく時間を割いて話すことができますし、実際にそうしますが、その前にいくつかの例を見てみましょう。


===インスタンス
もしあなたがMonadの裏にある洞察について理解していなかったとしても、型の導くままに進めば、インスタンスを作ることができます。このことが実際に洞察を理解する長い道のりに繋がっていることに驚くことでしょう。少なくとも、Monadクラス一般に関して読むのに合わせていじることのできる具体的な例が得られるます。最初のいくつかの例は標準Preludeにあります。その他の例はモナド変換ライブラリ(mtl)[24]にあります。

*最も単純なMonadのインスタンスはIdentity[25]で、Dan Piponiの強くお勧めするブログ記事である"The Trivial Monad"[26]で述べられています。この記事は、「自明」ではありますが、Monad型クラスへの重要な導入であり、頭を働かせ始めるための良い問題が含まれています。

*次に単純なMonadのインスタンスはMaybeです。私たちは既にMaybeに対して、return/pureをどのように書くかを知っています。ではどうやって(>>=)を書くのでしょうか?では、型を考えて見ましょう。Maybeに特化すると、以下の型が得られます。
 
  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
 
 もし(>>=)への最初の引数がJust xならば、二番目の引数に適用できるa型の何か（すなわちx）を持っていることになります。そして、それはMaybe bとなり、これはまさに私たちが求めていたものです。(>>=)の最初の引数がNothingだったらどうでしょう?この場合、私たちは、a -> Maybe bの関数に適用できるものを何も持っていませんので、できることはひとつしかありません。つまり、Nothingを返します。リスト18にこのインスタンスを示します。既にここで何が行われているかに関するちょっとした洞察が得られています。もし、いくつかの関数を(>>=)でつなげることで計算を作り上げたら、いずれかの計算が失敗したら計算全体が失敗します（なぜなら、Nothing >>= fは、fにかかわらずNothingになるからです）。計算全体は、構成する全ての関数が個別に成功した場合にのみ成功します。というわけで、Maybeモナドは、失敗しうる計算をモデル化します。
 
  instance Monad Maybe where
    return = Just
    (Just x) >>= g = g x
    Nothing  >>= _ = Nothing
  
  リスト18: MaybeのMonadインスタンス

*リスト構築子である[]のMonadのインスタンスは、Applicativeのインスタンスに似ています。この実装は練習問題として残しておきます。型に従いましょう!

*もちろん、IO構築子は有名なモナドですが、その実装はいくらか魔術的で、実際コンパイラごとに異なります。IOモナドだけが魔術的なモナドであるということを強調する価値があります。IOモナドを使うと、全く純粋な方法で、副作用のある計算を表す値を組み上げることができます。IO型の特別な値であるmainは、ランタイムによって取り上げられ、実際に実行されて、実際の副作用を引き起こします。その他の全てのモナドは関数的に純粋で、特別なコンパイラのサポートを必要としません。しばしばモナド的な値を「副作用のある計算」と言いますが、これはいくつかのモナドが副作用のあるようなコードを書くことを許すからで、実際にはモナドがこれらの明らかな副作用を関数的に純粋な方法で実装するのを隠しているのです。

*先に述べたように、((->) e)はリーダーモナドとして知られています。なぜなら、それが型eの値が読み込み専用の環境として存在するような計算をあらわすからです。((->) e)のMonadのインスタンスを自分で書いてみてください。
 
 Control.Monad.Readerモジュール[27]は、(e -> a)の便利なnewtypeラッパーであるReader e a型と、適切なMonadインスタンス、そしてReader特有の便利な関数を提供しています。それには、ask（環境を取得する）、asks（環境の関数を取得する）、そしてlocal（異なる環境で下位の計算を実行する）などが含まれます。

