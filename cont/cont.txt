整数のリストの各要素の積を求めることを考えます。例えば、[1, 2, 3]なら答えは6です。素直に書くと、

 mul1 :: Num a => [a] -> a
 mul1 = foldr (*) 1

ですが、これで終わってしまうとつまらないので再帰呼び出しする関数に展開してみます。

 mul2 :: Num a => [a] -> a
 mul2 []     = 1
 mul2 (x:xs) = x * mul2 xs

ここでできた関数に0を含む無限リストを与えてみます。例えば、

 mul2 [100, 99..]

を計算してみます。無限リストなので無限に計算をし続けて止まりません。しかし、リストに0が含まれていたら積は必ず0になるので0を返すようになっていて欲しいものです。そこで、引数が0の場合に関しての条件を追加します。

 mul3 :: Num a => [a] -> a
 mul3 []     = 1
 mul3 (0:xs) = 0
 mul3 (x:xs) = x * mul2 xs

これでめでたく、

 mul3 [100, 99..]

は0を返すようになりました。ここで、どのように呼び出されているかを考えてみます。100からだと大変なので[2, 1..]を考えることにします。すると、

 mul3 [2, 1..]
 2 * mul3 [1, 0..]
 2 * 1 * mul3 [0, -1..]
 2 * 1 * 0

というように計算されることがわかります。ということは、最終的に2*1*0が計算されていることになります。最初の例だと、100*99*..*0が計算されていることになります。答えが0になることがわかっているのにわざわざ計算するのは馬鹿らしいのでこの部分の計算をせずに済むようにしたいと思います。

そこで、この関数をCPS変換します。CPSはContinuation Passing Styleの略で、すべての関数呼び出しを末尾呼び出しにするテクニックです。CPS変換では、関数から値を返す代わりに関数を引数に取り、結果の値をその関数に渡します。例えば、

 plus x y = x + y

という関数は、

 plusCps x y r = r $ x + y

というようにします。rが結果を受け取る関数です。もうひとつ例を挙げてみます。

 f x = g x + 1
 g x = h x + i x
 h x = x + 2
 i x = x - 2

というような四つの関数を考えます。まず、fはgを呼び出した後で1を足す関数です。これをCPS変換すると、

 f x r = g x (\y -> r $ y + 1)

のようになります。つまり、g xの結果を受け取る関数をその場で作り、その関数に渡されたgの結果と1を足して、f自身の結果を出力する関数rに渡します。同様にすると、

 g x r = h x (\y -> i x (\z -> r $ y + z))
 h x r = r $ x + 2
 i x r = r $ x - 2

のように変換できます。

CPS変換をmul3に適用すると、

 mul4 :: Num a => [a] -> a
 mul4 :: mulCps id
  where
      mulCps :: Num a => (a -> b) -> [a] -> b
      mulCps f []     = f 1
      mulCps f (0:xs) = f 0
      mulCps f (x:xs) = mulCps (\y -> f $ x * y) xs

となります。さて、ここで最初に渡された出力関数（結果を受け取るための関数）を覚えておいて任意の時点で呼べば途中の計算を飛ばして結果を渡すことができます。つまり、こんな感じです。

 mul5 :: Num a => [a] -> a
 mul5 :: mulCps id
  where
      mulCps f = mulCps' f
       where
           mulCps' g []     = g 1
           mulCps' _ (0:xs) = f 0
           mulCps' g (x:xs) = mulCps' (\y -> g $ x * y) xs

fは最初に渡された出力関数で、gは各ステージで渡された出力関数です。リストに0が含まれていたらfを呼び出すことで途中の計算を飛ばして結果を最初の出力関数に渡すことができます。
